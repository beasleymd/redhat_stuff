---
- name: Renew and replace certs that expire in exactly 7 days (VaaS)
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    # === Required auth / endpoints ===
    vaas_api_key: "{{ venafi_api_key }}"              # Prefer injecting via AAP Credential
    tenant_base_url: "https://eval-85300634.venafi.cloud"
    global_api_url:  "https://api.venafi.cloud"

    # === Tuning ===
    page_size: 500
    poll_interval_sec: 5
    poll_timeout_sec: 180
    # If your Application has multiple Issuing Templates, you can override here:
    # issuing_template_id_override: "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"

    # === Local working dir (controller) ===
    work_dir: "/tmp/vaas_day7_renewals"

    # === Optional deployment to Linux targets ===
    deploy_enabled: false                 # set true to copy new cert/key to hosts in group 'tls_targets'
    deploy_group: "tls_targets"
    deploy_cert_path: "/etc/pki/tls/certs/{{ item.subjectCN[0] }}.crt"
    deploy_key_path:  "/etc/pki/tls/private/{{ item.subjectCN[0] }}.key"
    service_to_reload: ""                 # e.g. "nginx" or "httpd"; leave blank to skip reload

  pre_tasks:
    - name: Ensure working dir exists
      ansible.builtin.file:
        path: "{{ work_dir }}"
        state: directory
        mode: "0700"

    - name: Assert API key is present
      ansible.builtin.assert:
        that:
          - vaas_api_key is defined
          - vaas_api_key | length > 0
        fail_msg: "Set venafi_api_key (AAP var/cred)."

  tasks:
    # --- 1) Discover certs expiring in <= 7 days (reuse your previous gather or do a fresh query) ---
    - name: Get all certificates (paged)
      ansible.builtin.uri:
        url: "{{ global_api_url }}/outagedetection/v1/certificates?ownershipTree=false&excludeSupersededInstances=false&limit={{ page_size }}"
        method: GET
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key }}"
        return_content: true
        status_code: 200
      register: cert_page

    - name: Parse certificates JSON
      ansible.builtin.set_fact:
        all_certs: "{{ (cert_page.json | default(cert_page.content | from_json)).certificates | default([]) }}"

    - name: Compute now (UTC, ISO8601)
      ansible.builtin.set_fact:
        now_iso: "{{ lookup('pipe','date -u +%Y-%m-%dT%H:%M:%SZ') }}"

    - name: Build candidates with days_left
      ansible.builtin.set_fact:
        candidates: >-
          {{
            all_certs
            | selectattr('validTo','defined')
            | map('combine',
                  [{'days_left':
                      (((item.validTo | to_datetime) - (now_iso | to_datetime)).days)
                   } for item in all_certs if item.validTo is defined]
                 )
          }}

    - name: Filter to exactly day 7
      ansible.builtin.set_fact:
        expiring_day7: "{{ (all_certs | json_query(query)) | default([]) }}"
      vars:
        # Select items where floor(day diff) == 7
        query: "[?((to_datetime(validTo)-to_datetime(`{{ now_iso }}`)).days==`7`)]"

    - name: Short preview
      ansible.builtin.debug:
        msg: "{{ expiring_day7 | map(attribute='certificateName') | list }}"

    - name: Skip if nothing to renew
      ansible.builtin.meta: end_play
      when: expiring_day7 | length == 0

    # --- 2) Load Applications to find Issuing Template IDs (mapped on each app) ---
    - name: List Applications (Outage Detection API)
      ansible.builtin.uri:
        url: "{{ global_api_url }}/outagedetection/v1/applications?ownerDetails=false&ownershipCheck=false&issuingTemplateAssigned=true&ownershipTree=false"
        method: GET
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key }}"
        return_content: true
        status_code: 200
      register: apps_raw

    - name: Parse applications
      ansible.builtin.set_fact:
        apps_parsed: "{{ apps_raw.json | default(apps_raw.content | from_json) }}"
        apps_by_id: "{{ dict((apps_parsed.applications | default([])) | map('extract', attribute='id') | zip(apps_parsed.applications | default([]))) }}"

    # --- 3) For each expiring cert:
    #       - derive CN and SANs
    #       - pick an associated applicationId and issuing template ID
    #       - generate key + CSR locally
    #       - POST /v1/certificaterequests (renewal)
    #       - poll until ISSUED
    #       - download cert (PEM)
    #       - optional: deploy to targets
    - name: Renew certs expiring on day 7
      block:
        - name: Iterate expiring certs
          ansible.builtin.include_tasks: renew_one.yml
          loop: "{{ expiring_day7 }}"
          loop_control:
            loop_var: cert_item
      rescue:
        - ansible.builtin.debug:
            msg: "At least one renewal failed; see prior errors."


  # --- Embedded task file for clarity (no separate file needed in AAP) ---
  # tasks_from: renew_one.yml
  
    - name: Extract certificate fields
      ansible.builtin.set_fact:
        cert_id: "{{ cert_item.id | default(cert_item.certificateId) }}"
        subject_cns: "{{ cert_item.subjectCN | default([]) }}"
        cn_primary: "{{ (cert_item.subjectCN | default(['unnamed']))[0] }}"
        san_dns: "{{ (cert_item.subjectAlternativeNamesByType.dNSName | default([])) }}"
        # Pick one associated applicationId (first instance's first app)
        app_id: >-
          {{
            (cert_item.instances | default([]) | map(attribute='applicationIds') | list | first | default([]) | first)
          }}
        app_obj: "{{ apps_by_id.get(app_id, {}) }}"
        # From the app, pick an issuing template (override if provided)
        issuing_template_id: >-
          {{
            issuing_template_id_override
              | default( (app_obj.certificateIssuingTemplateAliasIdMap | default({})).values() | list | first, true)
          }}

    - name: Guard that we have minimal inputs for renewal
      ansible.builtin.assert:
        that:
          - cert_id is defined
          - app_id is defined
          - issuing_template_id is defined
        fail_msg: "Missing cert_id/app_id/issuing_template_id for {{ cn_primary }}"

    - name: Make a per-cert work dir
      ansible.builtin.file:
        path: "{{ work_dir }}/{{ cert_id }}"
        state: directory
        mode: "0700"

    - name: Generate a new private key (PEM)
      community.crypto.openssl_privatekey:
        path: "{{ work_dir }}/{{ cert_id }}/key.pem"
        size: 2048
        type: RSA
        mode: "0600"

    - name: Build CSR from existing CN/SANs
      community.crypto.openssl_csr:
        path: "{{ work_dir }}/{{ cert_id }}/req.csr"
        privatekey_path: "{{ work_dir }}/{{ cert_id }}/key.pem"
        common_name: "{{ cn_primary }}"
        subject_alt_name: "{{ san_dns | map('regex_replace','^(.*)$','DNS:\\1') | list }}"
        mode: "0644"
      register: csr_out

    - name: Read CSR text
      ansible.builtin.slurp:
        path: "{{ work_dir }}/{{ cert_id }}/req.csr"
      register: csr_slurp

    - name: Submit renewal request
      ansible.builtin.uri:
        url: "{{ global_api_url }}/v1/certificaterequests"
        method: POST
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key }}"
          content-type: "application/json"
        body_format: json
        body:
          certificateOwnerUserId: null
          certificateSigningRequest: "{{ (csr_slurp.content | b64decode) | replace('\n','\\n') }}"
          applicationId: "{{ app_id }}"
          certificateIssuingTemplateId: "{{ issuing_template_id }}"
          existingCertificateId: "{{ cert_id }}"
        status_code: [200, 201]
        return_content: true
      register: renew_resp

    - name: Extract certificateRequestId and initial status
      ansible.builtin.set_fact:
        request_id: "{{ (renew_resp.json.certificateRequests | default([]) | first).id }}"
        request_status: "{{ (renew_resp.json.certificateRequests | default([]) | first).status | default('PENDING') }}"

    - name: Poll request status until ISSUED (or timeout)
      ansible.builtin.uri:
        url: "{{ global_api_url }}/v1/certificaterequests/{{ request_id }}"
        method: GET
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key }}"
        status_code: 200
        return_content: true
      register: poll
      until: "(poll.json.status | default('PENDING')) in ['ISSUED','FAILED','REJECTED']"
      retries: "{{ (poll_timeout_sec // poll_interval_sec) | int }}"
      delay: "{{ poll_interval_sec }}"

    - name: Fail if not ISSUED
      ansible.builtin.fail:
        msg: "Renewal for {{ cn_primary }} ended in status {{ poll.json.status }}"
      when: poll.json.status != 'ISSUED'

    - name: Capture new certificate ID
      ansible.builtin.set_fact:
        new_cert_id: "{{ (poll.json.certificateIds | default([]) | first) }}"

    - name: Download renewed certificate (PEM)
      ansible.builtin.uri:
        url: "{{ global_api_url }}/v1/certificates/{{ new_cert_id }}/contents?format=PEM"
        method: GET
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key }}"
        return_content: true
        status_code: 200
      register: pem_resp

    - name: Write renewed cert to disk
      ansible.builtin.copy:
        dest: "{{ work_dir }}/{{ cert_id }}/cert.pem"
        content: "{{ (pem_resp.json.certificate | default(pem_resp.content | b64decode)) }}"
        mode: "0644"

    - name: Optional deploy to Linux targets
      when: deploy_enabled | bool
      block:
        - name: Push key
          ansible.builtin.copy:
            src: "{{ work_dir }}/{{ cert_id }}/key.pem"
            dest: "{{ deploy_key_path }}"
            owner: root
            group: root
            mode: "0600"
          delegate_to: "{{ item }}"
          with_inventory_hostnames: "{{ deploy_group }}"

        - name: Push cert
          ansible.builtin.copy:
            src: "{{ work_dir }}/{{ cert_id }}/cert.pem"
            dest: "{{ deploy_cert_path }}"
            owner: root
            group: root
            mode: "0644"
          delegate_to: "{{ item }}"
          with_inventory_hostnames: "{{ deploy_group }}"

        - name: Reload service (if set)
          ansible.builtin.service:
            name: "{{ service_to_reload }}"
            state: reloaded
          when: service_to_reload | length > 0
          delegate_to: "{{ item }}"
          with_inventory_hostnames: "{{ deploy_group }}"

    - name: Report success
      ansible.builtin.debug:
        msg:
          cn: "{{ cn_primary }}"
          old_cert_id: "{{ cert_id }}"
          new_cert_id: "{{ new_cert_id }}"
          saved_to: "{{ work_dir }}/{{ cert_id }}"
