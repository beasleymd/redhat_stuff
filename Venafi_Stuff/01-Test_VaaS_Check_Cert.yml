---
- name: Gather Venafi Cloud applications and certificates
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    # === Required ===
    vaas_api_key: "{{ venafi_api_key }}"   # or inject via AAP credential as a variable
    tenant_base_url: "https://eval-85300634.venafi.cloud" # your tenant base
    global_api_url:  "https://api.venafi.cloud"
    # Many APIs are also available under api.venafi.cloud; most tenants proxy on their base URL too.

    # === Tuning ===
    cert_limit: 1000
    cert_params: "ownershipTree=false&excludeSupersededInstances=false"

    # === Output files ===
    out_dir: "/tmp/venafi_gather"
    apps_json: "{{ out_dir }}/applications.json"
    certs_json: "{{ out_dir }}/certificates.json"



  pre_tasks:
    - name: Ensure output directory exists
      ansible.builtin.file:
        path: "{{ out_dir }}"
        state: directory
        mode: "0755"

    - name: Fail fast if API key missing
      ansible.builtin.assert:
        that:
          - vaas_api_key is defined
          - vaas_api_key | length > 0
        fail_msg: "Set venafi_api_key extra var or inject vaas_api_key from an AAP credential."

  tasks:
    - name: Get Venafi Outage Detection Applications
      ansible.builtin.uri:
        url: "https://api.venafi.cloud/outagedetection/v1/applications?ownerDetails=false&ownershipCheck=false&issuingTemplateAssigned=false&ownershipTree=false"
        method: GET
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key | default('REDACT_ME') }}"
        return_content: true
        status_code: 200
      register: vaas_apps

    - name: Parse apps JSON (prefer .json, fall back to .content)
      ansible.builtin.set_fact:
        vaas_parsed: "{{ vaas_apps.json | default(vaas_apps.content | from_json) }}"
    
    # Examples of pulling data youâ€™re likely to want
    - name: List app names
      ansible.builtin.debug:
        msg: "{{ vaas_parsed.applications | map(attribute='name') | list }}"
    
    - name: Grab the 'mbredeme' app object
      ansible.builtin.set_fact:
        mbredeme_app: >-
          {{
            (vaas_parsed.applications
             | selectattr('name','equalto','mbredeme')
             | list
            ) | first
          }}
    
    - name: Show mbredeme details
      ansible.builtin.debug:
        msg:
          fqdn: "{{ mbredeme_app.fullyQualifiedDomainNames | default([]) | to_nice_yaml }}"
          ports: "{{ mbredeme_app.ports | default([]) | to_nice_yaml }}"
          id: "{{ mbredeme_app.id | to_nice_yaml }}"

    # --- Certificates (Outage Detection API) ---
    # NOTE: This grabs up to 'cert_limit' results. If you have more, see 'Pagination' note below.
    - name: Get Certificates (up to {{ cert_limit }})
      ansible.builtin.uri:
        url: "https://api.venafi.cloud/outagedetection/v1/certificates?ownershipTree=false&excludeSupersededInstances=false&limit=1000"
        method: GET
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key | default('REDACT_ME') }}"
        return_content: true
        status_code: [200]
      register: vaas_certs

    - name: Parse cert JSON (prefer .json, fall back to .content)
      ansible.builtin.set_fact:
        vaas_parsed_certs: "{{ vaas_certs.json | default(vaas_certs.content | from_json) }}"

    - name: List cert names
      ansible.builtin.debug:
        msg: "{{ vaas_parsed_certs.certificates | map(attribute='certificateName') | list }}"


 # ========= NEW: "expiring within 7 days" =========

    - name: Compute current time (UTC) as ISO8601 (no facts required)
      ansible.builtin.set_fact:
        now_iso: "{{ lookup('pipe','date -u +%Y-%m-%dT%H:%M:%SZ') }}"

    - name: Init expiring_soon list
      ansible.builtin.set_fact:
        expiring_soon: []

    - name: Build 'expiring_soon' (validTo within 7 days from now)
      ansible.builtin.set_fact:
        expiring_soon: "{{ expiring_soon + [ item | combine({'days_left': days_left}) ] }}"
      vars:
        days_left: >-
          {{
            (
              (item.validTo | to_datetime) - (now_iso | to_datetime)
            ).days
          }}
      loop: "{{ vaas_parsed_certs.certificates | default([]) }}"
      when:
        - item.validTo is defined
        - item.validTo | string | length > 0
        - ((item.validTo | to_datetime) - (now_iso | to_datetime)).days <= 7
        - ((item.validTo | to_datetime) - (now_iso | to_datetime)).days >= 0

    - name: Preview expiring soon (sorted by days_left)
      ansible.builtin.debug:
        msg: >-
          {{
            (expiring_soon | sort(attribute='days_left'))
            | to_nice_json
          }}

    # ========= /NEW =========

    # ------------------ PICK ONE OF THE PLAYS BELOW ------------------

# PLAY 2 (SSH): connect over SSH to hosts in the 'aws_ec2' group
- name: Reach AWS web servers (SSH)
  hosts: aws_ec2
  gather_facts: false
  vars:
    # Set this here or in group_vars/aws_ec2.yml
    ansible_user: ec2-user       # RHEL AMIs commonly use 'ec2-user'
    # ansible_port: 22
    # become: true
    # become_method: sudo
  tasks:
    - name: Connectivity check
      ansible.builtin.ping:

    - name: Show hostname
      ansible.builtin.command: hostname
      register: hn

    - name: Print hostname
      ansible.builtin.debug:
        var: hn.stdout

# PLAY 2 (SSM): reach hosts via AWS SSM (no inbound port 22 required)
# - name: Reach AWS web servers (SSM)
#   hosts: aws_ec2
#   gather_facts: false
#   vars:
#     ansible_connection: amazon.aws.aws_ssm
#     ansible_aws_ssm_region: us-east-1   # set your region
#     ansible_user: ec2-user
#   tasks:
#     - name: Connectivity check
#       ansible.builtin.ping: