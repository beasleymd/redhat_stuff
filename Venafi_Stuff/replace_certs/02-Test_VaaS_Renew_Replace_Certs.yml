---
- name: Renew & replace VaaS certs expiring in ≤ 7 days
  hosts: localhost
  connection: local
  gather_facts: false

  vars:
    # === Required ===
    vaas_api_key: "{{ venafi_api_key }}"
    tenant_base_url: "https://eval-85300634.venafi.cloud"
    global_api_url:  "https://api.venafi.cloud"

    # === Tuning ===
    page_size: 1000
    poll_interval_sec: 5
    poll_timeout_sec: 180
    # issuing_template_id_override: "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"

    # === Work dir on controller ===
    work_dir: "/tmp/vaas_day7_or_less"

    # === Optional Linux deployment ===
    deploy_enabled: false
    deploy_group: "tls_targets"
    deploy_cert_path: "/etc/pki/tls/certs/{{ item.subjectCN[0] }}.crt"
    deploy_key_path:  "/etc/pki/tls/private/{{ item.subjectCN[0] }}.key"
    service_to_reload: ""      # e.g. "nginx" | "httpd" (blank = skip)

  pre_tasks:
    - name: Ensure working dir exists
      ansible.builtin.file:
        path: "{{ work_dir }}"
        state: directory
        mode: "0700"

    - name: Assert API key present
      ansible.builtin.assert:
        that:
          - vaas_api_key is defined
          - vaas_api_key | length > 0
        fail_msg: "Set venafi_api_key (AAP var/credential)."

  tasks:
    # 1) Gather certs
    - name: Get certificates (paged up to {{ page_size }})
      ansible.builtin.uri:
        url: "{{ global_api_url }}/outagedetection/v1/certificates?ownershipTree=false&excludeSupersededInstances=false&limit={{ page_size }}"
        method: GET
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key }}"
        return_content: true
        status_code: 200
      register: cert_page

    - name: Parse certs
      ansible.builtin.set_fact:
        all_certs: "{{ (cert_page.json | default(cert_page.content | from_json)).certificates | default([]) }}"

    - name: Compute now (UTC)
      ansible.builtin.set_fact:
        now_iso: "{{ lookup('pipe','date -u +%Y-%m-%dT%H:%M:%SZ') }}"

    # 2) Build list of certs expiring in ≤ 7 days (no json_query)
    - name: Init expiring_soon
      ansible.builtin.set_fact:
        expiring_soon: []

    - name: Append certs expiring in ≤ 7 days
      ansible.builtin.set_fact:
        expiring_soon: "{{ expiring_soon + [ item | combine({'days_left': days_left}) ] }}"
      vars:
        days_left: "{{ ((item.validTo | to_datetime) - (now_iso | to_datetime)).days }}"
      loop: "{{ all_certs }}"
      when:
        - item.validTo is defined
        - days_left >= 0
        - days_left <= 7

    - name: Preview expiring soon (sorted)
      ansible.builtin.debug:
        msg: "{{ expiring_soon | sort(attribute='days_left') | map(attribute='certificateName') | list }}"

    - name: Stop if nothing to renew
      ansible.builtin.meta: end_play
      when: expiring_soon | length == 0

    # 3) Load applications to map applicationId -> issuing template IDs
    - name: Get Applications (with issuing templates)
      ansible.builtin.uri:
        url: "{{ global_api_url }}/outagedetection/v1/applications?ownerDetails=false&ownershipCheck=false&issuingTemplateAssigned=true&ownershipTree=false"
        method: GET
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key }}"
        return_content: true
        status_code: 200
      register: apps_raw

    - name: Build app lookup
      ansible.builtin.set_fact:
        apps_parsed: "{{ apps_raw.json | default(apps_raw.content | from_json) }}"
        apps_by_id: "{{ dict((apps_parsed.applications | default([])) | map(attribute='id') | zip(apps_parsed.applications | default([]))) }}"

    # 4) Renew each expiring cert (loop include)
    - name: Renew each expiring cert (≤ 7 days)
      block:
        - name: run renew_one for each item
          ansible.builtin.include_tasks: renew_one.yml
          loop: "{{ expiring_soon }}"
          loop_control:
            loop_var: cert_item
      rescue:
        - ansible.builtin.debug:
            msg: "At least one renewal failed; see prior errors."



# --- PLAY 2: reach (and optionally deploy to) AWS web servers over SSH ---
- name: Reach & (optional) deploy to AWS web servers (SSH)
  hosts: aws_ec2
  gather_facts: false
  vars:
    # If not set in group_vars/aws_ec2.yml, set here:
    ansible_user: ec2-user
    # become: true   # uncomment if you’ll write to /etc
    # become_method: sudo

    # Pull values from the localhost play:
    expiring_list: "{{ hostvars['localhost']['expiring_soon'] | default([]) }}"
    work_dir_ctrl: "{{ hostvars['localhost']['work_dir'] | default('/tmp/vaas_day7_or_less') }}"
    deploy_enabled_ctrl: "{{ hostvars['localhost']['deploy_enabled'] | default(false) | bool }}"
    deploy_cert_path_ctrl: "{{ hostvars['localhost']['deploy_cert_path'] | default('/etc/pki/tls/certs/{{ item.subjectCN[0] }}.crt') }}"
    deploy_key_path_ctrl:  "{{ hostvars['localhost']['deploy_key_path']  | default('/etc/pki/tls/private/{{ item.subjectCN[0] }}.key') }}"
    service_to_reload_ctrl: "{{ hostvars['localhost']['service_to_reload'] | default('') }}"

  tasks:
    - name: Connectivity check
      ansible.builtin.ping:

    - name: Stop if deploy not enabled
      ansible.builtin.meta: end_play
      when: not deploy_enabled_ctrl

    - name: Copy renewed cert to target
      ansible.builtin.copy:
        src: "{{ work_dir_ctrl }}/{{ item.subjectCN[0] }}.crt"   # file created by renew step on controller
        dest: "{{ deploy_cert_path_ctrl }}"
        owner: root
        group: root
        mode: "0644"
      loop: "{{ expiring_list }}"
      loop_control:
        label: "{{ item.subjectCN[0] }}"
      # Optional safety: only deploy when this host matches CN or a SAN you expect
      # when: inventory_hostname is search(item.subjectCN[0])

    - name: Copy renewed key to target
      ansible.builtin.copy:
        src: "{{ work_dir_ctrl }}/{{ item.subjectCN[0] }}.key"
        dest: "{{ deploy_key_path_ctrl }}"
        owner: root
        group: root
        mode: "0600"
      loop: "{{ expiring_list }}"
      loop_control:
        label: "{{ item.subjectCN[0] }}"

    - name: Reload service if requested
      ansible.builtin.service:
        name: "{{ service_to_reload_ctrl }}"
        state: reloaded
      when: service_to_reload_ctrl | length > 0



