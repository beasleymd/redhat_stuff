---
- name: venafi_certificate_cloud
  hosts: localhost
  connection: local
  gather_facts: false
  become: true

  vars:
    # Inject via Controller credential or env var VENAFI_APIKEY
    venafi_api_key: "{{ venafi_api_key | default(lookup('env','VENAFI_APIKEY'), true) }}"
    venafi_zone: "{{ venafi_zone | default('MyApp\\Default') }}"

    # Certificate request parameters
    common_name: "www.example.com"
    dns_sans:
      - "www.example.com"
      - "example.com"

    # Output destinations (RHEL-style paths)
    cert_dest_path:  "/etc/pki/tls/certs/{{ common_name }}.crt"
    chain_dest_path: "/etc/pki/tls/certs/{{ common_name }}-chain.crt"

    # Optional service restart
    restart_handler: "restart nginx"

  pre_tasks:
    - name: Ensure cert directories exist
      ansible.builtin.file:
        path: "/etc/pki/tls/certs"
        state: directory
        mode: "0755"

  tasks:
    - name: Enroll/renew certificate via Venafi as a Service (service-side CSR)
      venafi.machine_identity.venafi_certificate:
        token: "{{ venafi_api_key }}"
        zone: "{{ venafi_zone }}"
        common_name: "{{ common_name }}"
        csr_origin: service                 # VaaS generates CSR/key (no local key/csr paths)

        # Your collection version expects 'cert_path' (not 'path')
        cert_path: "{{ cert_dest_path }}"

        # Chain handling: since we want a chain, we must provide chain_path
        chain_option: last
        chain_path: "{{ chain_dest_path }}"

        # SANs: comma-separated DNS entries
        alt_name: "{{ dns_sans | map('regex_replace','^(.*)$','DNS:\\1') | join(',') }}"

        unsafe_writes: true
      register: certout
      notify: "{{ restart_handler }}"

    - name: Show module result
      ansible.builtin.debug:
        var: certout

  handlers:
    - name: restart nginx
      ansible.builtin.service:
        name: nginx
        state: restarted
