---
# Play 1: Find certs expiring in ≤ 3 days; issue new ones via Venafi module
- name: Renew certs expiring in ≤ 3 days and stage on controller
  hosts: localhost
  gather_facts: false
  collections:
    - venafi.machine_identity

  vars:
    # === Required ===
    vaas_api_key: "{{ venafi_api_key }}"
    vaas_api_url: "https://api.venafi.cloud"
    # Zone is Application\IssuingTemplate (escape the backslash in YAML)
    zone: "MyApplication\\MyIssuingTemplate"

    # === Tuning ===
    page_size: 1000
    work_dir: "/tmp/vaas_expiring3"
    # Optional: set the CN you want if you’re targeting a single name; otherwise we use the CN from search results
    # override_common_name: "app.internal.example"

  pre_tasks:
    - name: Ensure working dir exists
      ansible.builtin.file:
        path: "{{ work_dir }}"
        state: directory
        mode: "0700"

    - name: Assert API key present
      ansible.builtin.assert:
        that:
          - vaas_api_key is defined
          - vaas_api_key | length > 0
        fail_msg: "Set venafi_api_key (AAP var/credential)."

  tasks:
    # --- search for certs expiring in ≤ 3 days
    - name: Compute window (UTC)
      ansible.builtin.set_fact:
        now_iso: "{{ lookup('pipe','date -u +%Y-%m-%dT%H:%M:%SZ') }}"
        plus3_iso: "{{ lookup('pipe','date -u -d +3days +%Y-%m-%dT%H:%M:%SZ') }}"

    - name: Search expiring (ACTIVE) certs via VaaS certificatesearch
      ansible.builtin.uri:
        url: "{{ vaas_api_url }}/outagedetection/v1/certificatesearch"
        method: POST
        headers:
          accept: "application/json"
          tppl-api-key: "{{ vaas_api_key }}"
        body_format: json
        body:
          expression:
            operands:
              - { field: "certificateStatus", operator: "EQ",  value: "ACTIVE" }
              - { field: "validityEnd",        operator: "GTE", value: "{{ now_iso }}" }
              - { field: "validityEnd",        operator: "LTE", value: "{{ plus3_iso }}" }
          ordering:
            orders:
              - { field: "validityEnd", direction: "ASC" }
          paging:
            pageNumber: 0
            pageSize: "{{ page_size }}"
        status_code: 200
        return_content: true
      register: cert_page

    - name: Build expiring list
      ansible.builtin.set_fact:
        expiring_soon: "{{ (cert_page.json | default(cert_page.content | from_json)).certificates | default([]) }}"

    - name: Stop if nothing to renew
      ansible.builtin.meta: end_play
      when: expiring_soon | length == 0

    # --- for each expiring cert, request a new one using the module
    - name: Issue new certs via venafi_certificate (pickup=true)
      venafi.machine_identity.venafi_certificate:
        connection: cloud
        url: "{{ vaas_api_url }}"
        token: "{{ vaas_api_key }}"
        zone: "{{ zone }}"
        # Use the CN from the expiring cert (or override if you set override_common_name)
        common_name: "{{ override_common_name | default(item.subjectCN[0], true) }}"
        # If you need SANs, add them here (safe default is CN only)
        san_dns: ["{{ override_common_name | default(item.subjectCN[0], true) }}"]
        algorithm: "RSA"
        key_size: 2048
        chain_option: "RootFirst"
        pickup: true
        timeout: 300
        state: present
        privatekey_path:  "{{ work_dir }}/{{ item.subjectCN[0] }}.key"
        certificate_path: "{{ work_dir }}/{{ item.subjectCN[0] }}.crt"
        chain_path:       "{{ work_dir }}/{{ item.subjectCN[0] }}-chain.crt"
      loop: "{{ expiring_soon }}"
      loop_control:
        label: "{{ item.subjectCN[0] }}"

    # --- Record expected serial/fingerprint for verification later
    - name: Read metadata of newly issued certs (serial, notAfter, SHA256 FP)
      ansible.builtin.shell: |
        set -o pipefail
        openssl x509 -in "{{ work_dir }}/{{ item.subjectCN[0] }}.crt" -noout -serial -enddate -fingerprint -sha256
      args:
        executable: /bin/bash
      register: issued_meta
      changed_when: false
      loop: "{{ expiring_soon }}"
      loop_control:
        label: "{{ item.subjectCN[0] }}"

    - name: Build expected map (CN -> serial/fingerprint/not_after)
      ansible.builtin.set_fact:
        issued_expected: "{{ issued_expected | default({}) | combine({ (item.item.subjectCN[0]): {
            'serial':      (item.stdout | regex_search('serial=([0-9A-F]+)', '\\1')),
            'fingerprint': (item.stdout | regex_search('SHA256 Fingerprint=([0-9A-F:]+)', '\\1')),
            'not_after':   (item.stdout | regex_search('notAfter=(.*)', '\\1'))
          } }, recursive=True) }}"
      loop: "{{ issued_meta.results }}"
      loop_control:
        label: "{{ item.item.subjectCN[0] }}"

# Play 2: Deploy to your RHEL9 AWS instances
- name: Deploy renewed certs to RHEL9 AWS instances
  hosts: aws_ec2
  become: true
  gather_facts: false

  vars:
    work_dir_ctrl: "{{ hostvars['localhost']['work_dir'] }}"
    expiring_list: "{{ hostvars['localhost']['expiring_soon'] }}"
    issued_expected: "{{ hostvars['localhost']['issued_expected'] | default({}) }}"

    # Optional service handling
    service_to_reload: ""      # e.g. nginx | httpd | cockpit (blank = skip)
    service_action: "reload"   # "reload" or "restart"

    # Optional VM reboot (ON by default for your request)
    reboot_hosts: true
    reboot_timeout: 900          # seconds to wait for reboot to complete
    reboot_connect_timeout: 10   # SSH connect timeout
    reboot_post_wait: 15         # seconds to wait after SSH comes back
    reboot_msg: "Reboot after cert deployment"

    # Optional live TLS verification (set a port to enable)
    verify_port: 0               # e.g. 9090 for Cockpit, 443 for nginx/httpd; 0 = skip
    verify_connect_host: "{{ inventory_hostname }}"   # override if needed
    verify_servername: "{{ inventory_hostname }}"     # SNI hostname; set to CN if virtual hosting

  tasks:
    - name: Ensure destination dirs
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: "0755"
      loop:
        - "/etc/pki/tls/certs"
        - "/etc/pki/tls/private"
        - "/etc/pki/ca-trust/source/anchors"

    - name: Copy private key(s)
      ansible.builtin.copy:
        src:  "{{ work_dir_ctrl }}/{{ item.subjectCN[0] }}.key"
        dest: "/etc/pki/tls/private/{{ item.subjectCN[0] }}.key"
        owner: root
        group: root
        mode: "0600"
      loop: "{{ expiring_list }}"
      loop_control: { label: "{{ item.subjectCN[0] }}" }

    - name: Copy certificate(s)
      ansible.builtin.copy:
        src:  "{{ work_dir_ctrl }}/{{ item.subjectCN[0] }}.crt"
        dest: "/etc/pki/tls/certs/{{ item.subjectCN[0] }}.crt"
        owner: root
        group: root
        mode: "0644"
      loop: "{{ expiring_list }}"
      loop_control: { label: "{{ item.subjectCN[0] }}" }

    - name: Copy chain(s) to trust anchors
      ansible.builtin.copy:
        src:  "{{ work_dir_ctrl }}/{{ item.subjectCN[0] }}-chain.crt"
        dest: "/etc/pki/ca-trust/source/anchors/{{ item.subjectCN[0] }}-chain.crt"
        owner: root
        group: root
        mode: "0644"
      loop: "{{ expiring_list }}"
      loop_control: { label: "{{ item.subjectCN[0] }}" }

    - name: Restore SELinux contexts
      ansible.builtin.command: "restorecon -Rv /etc/pki"
      changed_when: true

    - name: Update system trust store
      ansible.builtin.command: "update-ca-trust"
      changed_when: true

    - name: "{{ service_action | capitalize }} service if requested"
      ansible.builtin.service:
        name: "{{ service_to_reload }}"
        state: "{{ 'restarted' if service_action == 'restart' else 'reloaded' }}"
      when: service_to_reload | length > 0

    - name: Restart VMs (optional)
      ansible.builtin.reboot:
        reboot_timeout: "{{ reboot_timeout }}"
        connect_timeout: "{{ reboot_connect_timeout }}"
        post_reboot_delay: "{{ reboot_post_wait }}"
        msg: "{{ reboot_msg }}"
      when: reboot_hosts | bool

    # --- Verification: ensure hosts are back and using the NEW certs

    - name: Verify installed cert files match expected (serial & fingerprint)
      ansible.builtin.shell: |
        set -o pipefail
        CRT="/etc/pki/tls/certs/{{ item.subjectCN[0] }}.crt"
        if [ ! -f "$CRT" ]; then
          echo "MISSING_FILE"
          exit 2
        fi
        openssl x509 -in "$CRT" -noout -serial -fingerprint -sha256
      args:
        executable: /bin/bash
      register: installed_meta
      changed_when: false
      failed_when: false          # we'll assert cleanly in next task
      loop: "{{ expiring_list }}"
      loop_control:
        label: "{{ item.subjectCN[0] }}"

    - name: Assert installed files equal expected serial/fingerprint
      vars:
        cn: "{{ item.item.subjectCN[0] }}"
        expected: "{{ issued_expected[cn] | default({}) }}"
        got_serial: "{{ item.stdout | regex_search('serial=([0-9A-F]+)', '\\1') | default('') }}"
        got_fp: "{{ item.stdout | regex_search('SHA256 Fingerprint=([0-9A-F:]+)', '\\1') | default('') }}"
      ansible.builtin.assert:
        that:
          - item.rc == 0
          - expected is mapping
          - expected.serial is defined
          - expected.fingerprint is defined
          - got_serial == expected.serial
          - got_fp == expected.fingerprint
        fail_msg: >-
          Installed cert for {{ cn }} does not match expected.
          Expected serial={{ expected.serial }}, fp={{ expected.fingerprint }};
          Got serial={{ got_serial }}, fp={{ got_fp }}.
      loop: "{{ installed_meta.results }}"
      loop_control:
        label: "{{ item.item.subjectCN[0] }}"

    - name: Wait for service port (optional)
      ansible.builtin.wait_for:
        host: "{{ verify_connect_host }}"
        port: "{{ verify_port }}"
        delay: 0
        timeout: 90
        state: started
      when: verify_port | int > 0

    - name: Verify served certificate matches expected (optional)
      vars:
        # Choose which CN you expect the service to present; defaults to inventory hostname
        verify_cn: "{{ verify_servername }}"
        expected_served: "{{ issued_expected[verify_cn] | default({}) }}"
      ansible.builtin.shell: |
        set -o pipefail
        echo | openssl s_client -servername "{{ verify_servername }}" -connect "{{ verify_connect_host }}:{{ verify_port }}" 2>/dev/null \
          | openssl x509 -noout -serial -fingerprint -sha256
      args:
        executable: /bin/bash
      register: served_meta
      changed_when: false
      when:
        - verify_port | int > 0
        - issued_expected | length > 0
        - issued_expected[verify_servername] is defined

    - name: Assert served certificate equals expected (optional)
      vars:
        verify_cn: "{{ verify_servername }}"
        expected_served: "{{ issued_expected[verify_cn] | default({}) }}"
        served_serial: "{{ served_meta.stdout | regex_search('serial=([0-9A-F]+)', '\\1') | default('') }}"
        served_fp: "{{ served_meta.stdout | regex_search('SHA256 Fingerprint=([0-9A-F:]+)', '\\1') | default('') }}"
      ansible.builtin.assert:
        that:
          - served_meta is defined
          - expected_served is mapping
          - expected_served.serial is defined
          - expected_served.fingerprint is defined
          - served_serial == expected_served.serial
          - served_fp == expected_served.fingerprint
        fail_msg: >-
          Served cert (port {{ verify_port }}) does not match expected for {{ verify_cn }}.
          Expected serial={{ expected_served.serial }}, fp={{ expected_served.fingerprint }};
          Got serial={{ served_serial }}, fp={{ served_fp }}.
      when:
        - verify_port | int > 0
        - served_meta is defined
